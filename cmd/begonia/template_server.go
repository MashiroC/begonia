package main

var serviceTmplStr = `// Code generated by Begonia. DO NOT EDIT.
// versions:
// 	Begonia v1.0.2
// source: {{.source}} 
// begonia server file

{{ $sn := concat "_" .ServiceName }} {{/* example: _Echo */}}
{{ $recv := concat "*" .ServiceName }} {{/* example: *Echo */}}

package {{.package}}

import (
	"errors"
	"context"
	"github.com/MashiroC/begonia/internal/coding"
	"github.com/MashiroC/begonia/internal"
)

{{/* 序列化用的schema和coder 以及服务信息的FuncList */}}
var (
	{{$sn}}FuncList []coding.FunInfo
{{range .fi}}
	{{$snDo := concat $sn .Name }}
	{{$snDo}}InSchema  = ` + "`" + `{{.InSchema|raw}}` + "`" + `
	{{$snDo}}OutSchema = ` + "`" + `{{.OutSchema|raw}}` + "`" + `
	{{$snDo}}InCoder   coding.Coder
	{{$snDo}}OutCoder  coding.Coder
{{end}}
)



{{/* 序列化用的结构体 In是入参 Out是出参 */}}
{{range .fi}} 	{{$snDo := concat $sn .Name }}
type {{$snDo}}In struct {
	{{range $idx,$value:= .ParamTyp}}
		F{{$idx|add}} {{.}} {{ end -}}}

type {{$snDo}}Out struct {
	{{range $idx,$value:= .ResultTyp}}
		{{if ne $value "error"}}	F{{$idx|add}} {{.}} {{end}} {{end}}
}
{{end}}

func init() {
	internal.ServiceAppMode = internal.ServiceAppModeAst

	var err error
{{range .fi}} 	{{$snDo := concat $sn .Name }}
	{{$snDo}}InCoder, err = coding.NewAvro({{$snDo}}InSchema)
	if err != nil {
		panic(err)
	}
	{{$snDo}}OutCoder, err = coding.NewAvro({{$snDo}}OutSchema)
	if err != nil {
		panic(err)
	}
{{end}}

	{{$sn}}FuncList = []coding.FunInfo{
		{{range .fi}} 	{{$snDo := concat $sn .Name }}
			{
				Name: "{{.Name}}", 
				Mode: "avro", 
				InSchema: {{$snDo}}InSchema, 
				OutSchema: {{$snDo}}OutSchema }, 
		{{end}}
	}
}

func (d {{$recv}}) Do(ctx context.Context, fun string, param []byte) (result []byte, err error) {
	switch fun { 
{{range .fi}} 	{{$snDo := concat $sn .Name }}
	case "{{.Name}}":
		var in {{$snDo}}In
		err := {{$snDo}}InCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}
	{{if hasRes .ResultTyp}}
		{{makeRes .ResultTyp}} := d.{{.Name}}(
					{{if .HasContext}}ctx, {{end}}
					{{range $idx,$value := .ParamTyp}} in.F{{$idx|add}}, {{end}}
					)
		if err!=nil{
			return nil,err
		}
		var out {{$snDo}}Out
		{{range $idx,$value := .ResultTyp}}{{if ne $value "error"}} out.F{{$idx|add}} = res{{$idx|add}} {{end}}
		{{end}}
		res, err := {{$snDo}}OutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil
	{{else}}
		d.{{.Name}}( 
			{{range $idx,$value := .ParamTyp}} in.F{{$idx|add}}, {{end}}
			)
		return []byte{1},nil
	{{end}}
{{end}}
	default:
		err = errors.New("rpc call error: fun not exist")
	}
	return
}

func (d {{$recv}}) FuncList() []coding.FunInfo {
	return {{$sn}}FuncList
}`
