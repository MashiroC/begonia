package main

var serviceTmplStr = `// Code generated by Begonia. DO NOT EDIT.
// versions:
// 	Begonia v1.0.2
// source: {{.source}} 
// begonia server1 file

{{ $sn := concat "_" .ServiceName }} {{/* example: _Echo */}}
{{ $recv := concat "*" .ServiceName }} {{/* example: *Echo */}}

package {{.package}}

import (
	"log"
	"fmt"
	"context"
	"errors"

	"github.com/MashiroC/begonia/app"
	"github.com/MashiroC/begonia/app/coding"
	cRegister "github.com/MashiroC/begonia/core/register"
)

{{/* 序列化用的schema和coder 以及服务信息的FuncList */}}
var (
	{{$sn}}FuncList []cRegister.FunInfo
{{range .fi}}
	{{$snDo := concat $sn .Name }}
	{{$snDo}}InSchema  = ` + "`" + `{{.InSchema|raw}}` + "`" + `
	{{$snDo}}OutSchema = ` + "`" + `{{.OutSchema|raw}}` + "`" + `
	{{$snDo}}InCoder   coding.Coder
	{{$snDo}}OutCoder  coding.Coder
{{end}}
)



{{/* 序列化用的结构体 In是入参 Out是出参 */}}
{{range .fi}} 	{{$snDo := concat $sn .Name }}
type {{$snDo}}In struct {
	{{range $idx,$value:= .ParamTyp}}
		F{{$idx|add}} {{.}} {{ end -}}}

type {{$snDo}}Out struct {
	{{range $idx,$value:= .ResultTyp}}
		{{if ne $value "error"}}	F{{$idx|add}} {{.}} {{end}} {{end}}
}
{{end}}

func init() {
	app.ServiceAppMode = app.Ast

	var err error
{{range .fi}} 	{{$snDo := concat $sn .Name }}
	{{$snDo}}InCoder, err = coding.NewAvro({{$snDo}}InSchema)
	if err != nil {
		panic(err)
	}
	{{$snDo}}OutCoder, err = coding.NewAvro({{$snDo}}OutSchema)
	if err != nil {
		panic(err)
	}
{{end}}

	{{$sn}}FuncList = []cRegister.FunInfo{
		{{range .fi}} 	{{$snDo := concat $sn .Name }}
			{
				Name: "{{.Name}}", 
				InSchema: {{$snDo}}InSchema, 
				OutSchema: {{$snDo}}OutSchema }, 
		{{end}}
	}
}

func (d {{$recv}}) Do(ctx context.Context, fun string, param []byte) (result []byte, err error) {
	switch fun { 
{{range .fi}} 	{{$snDo := concat $sn .Name }}
	case "{{.Name}}":
		var in {{$snDo}}In
		err = {{$snDo}}InCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}
	{{if hasRes .ResultTyp}}
		var out {{$snDo}}Out

		func(){
		if re := recover() ; re != nil {
			log.Printf("[RECOVER] panic in remote func ast call: %s\n",re)
			err = errors.New(fmt.Sprintf("server1 func call recover: %s", re))
		}
		{{makeRes .ResultTyp}} := d.{{.Name}}(
					{{if .HasContext}}ctx, {{end}}
					{{range $idx,$value := .ParamTyp}} in.F{{$idx|add}}, {{end}}
					)
		{{if isLastError .ResultTyp}}
		if inErr != nil {
			err = inErr
			return
		}
		{{end}}
		
		{{range $idx,$value := .ResultTyp}}{{if ne $value "error"}} out.F{{$idx|add}} = res{{$idx|add}} {{end}}
		{{end}}
		}()
		if err!=nil{
			return
		}

		res, err := {{$snDo}}OutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil
	{{else}}
		func(){
			if re := recover() ; re != nil {
				log.Printf("[RECOVER] panic in remote func ast call: %s\n",re)
				err = errors.New(fmt.Sprintf("server1 func call recover: %s", re))
			}
		d.{{.Name}}( 
			{{range $idx,$value := .ParamTyp}} in.F{{$idx|add}}, {{end}}
			)
		}()

		result = app.NullReturn
		return
	{{end}}
{{end}}
	default:
		err = errors.New("rpc call error: fun not exist")
	}
	return
}

func (d {{$recv}}) FuncList() []cRegister.FunInfo {
	return {{$sn}}FuncList
}`
