// Code generated by Begonia. DO NOT EDIT.
// versions:
// 	Begonia v1.0.2
// source: ast.go
// begonia server file

package ast

import (
	"context"
	"errors"
	"github.com/MashiroC/begonia/app"
	"github.com/MashiroC/begonia/app/coding"
	cRegister "github.com/MashiroC/begonia/core/register"
)

var (
	_testRegisterFuncList []cRegister.FunInfo

	_testRegisterNullInSchema = `
{
			"namespace":"begonia.func.Null",
			"type":"record",
			"name":"In",
			"fields":[
				
			]
		}`
	_testRegisterNullOutSchema = `
{
			"namespace":"begonia.func.Null",
			"type":"record",
			"name":"Out",
			"fields":[
				
			]
		}`
	_testRegisterNullInCoder  coding.Coder
	_testRegisterNullOutCoder coding.Coder

	_testRegisterOnlyInputInSchema = `
{
			"namespace":"begonia.func.OnlyInput",
			"type":"record",
			"name":"In",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterOnlyInputOutSchema = `
{
			"namespace":"begonia.func.OnlyInput",
			"type":"record",
			"name":"Out",
			"fields":[
				
			]
		}`
	_testRegisterOnlyInputInCoder  coding.Coder
	_testRegisterOnlyInputOutCoder coding.Coder

	_testRegisterOnlyOutputInSchema = `
{
			"namespace":"begonia.func.OnlyOutput",
			"type":"record",
			"name":"In",
			"fields":[
				
			]
		}`
	_testRegisterOnlyOutputOutSchema = `
{
			"namespace":"begonia.func.OnlyOutput",
			"type":"record",
			"name":"Out",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterOnlyOutputInCoder  coding.Coder
	_testRegisterOnlyOutputOutCoder coding.Coder

	_testRegisterBothInAndOutInSchema = `
{
			"namespace":"begonia.func.BothInAndOut",
			"type":"record",
			"name":"In",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterBothInAndOutOutSchema = `
{
			"namespace":"begonia.func.BothInAndOut",
			"type":"record",
			"name":"Out",
			"fields":[
				{"name":"F1","type":"int","alias":"j"}

			]
		}`
	_testRegisterBothInAndOutInCoder  coding.Coder
	_testRegisterBothInAndOutOutCoder coding.Coder

	_testRegisterOutWithErrorInSchema = `
{
			"namespace":"begonia.func.OutWithError",
			"type":"record",
			"name":"In",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterOutWithErrorOutSchema = `
{
			"namespace":"begonia.func.OutWithError",
			"type":"record",
			"name":"Out",
			"fields":[
				{"name":"F1","type":"int","alias":"j"}

			]
		}`
	_testRegisterOutWithErrorInCoder  coding.Coder
	_testRegisterOutWithErrorOutCoder coding.Coder

	_testRegisterOutWithContextInSchema = `
{
			"namespace":"begonia.func.OutWithContext",
			"type":"record",
			"name":"In",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterOutWithContextOutSchema = `
{
			"namespace":"begonia.func.OutWithContext",
			"type":"record",
			"name":"Out",
			"fields":[
				{"name":"F1","type":"string","alias":"s"}

			]
		}`
	_testRegisterOutWithContextInCoder  coding.Coder
	_testRegisterOutWithContextOutCoder coding.Coder

	_testRegisterOutWithErrorAndContextInSchema = `
{
			"namespace":"begonia.func.OutWithErrorAndContext",
			"type":"record",
			"name":"In",
			"fields":[
				{"name":"F1","type":"int","alias":"i"}

			]
		}`
	_testRegisterOutWithErrorAndContextOutSchema = `
{
			"namespace":"begonia.func.OutWithErrorAndContext",
			"type":"record",
			"name":"Out",
			"fields":[
				{"name":"F1","type":"int","alias":"j"}

			]
		}`
	_testRegisterOutWithErrorAndContextInCoder  coding.Coder
	_testRegisterOutWithErrorAndContextOutCoder coding.Coder
)

type _testRegisterNullIn struct {
}

type _testRegisterNullOut struct {
}

type _testRegisterOnlyInputIn struct {
	F1 int
}

type _testRegisterOnlyInputOut struct {
}

type _testRegisterOnlyOutputIn struct {
}

type _testRegisterOnlyOutputOut struct {
	F1 int
}

type _testRegisterBothInAndOutIn struct {
	F1 int
}

type _testRegisterBothInAndOutOut struct {
	F1 int
}

type _testRegisterOutWithErrorIn struct {
	F1 int
}

type _testRegisterOutWithErrorOut struct {
	F1 int
}

type _testRegisterOutWithContextIn struct {
	F1 int
}

type _testRegisterOutWithContextOut struct {
	F1 string
}

type _testRegisterOutWithErrorAndContextIn struct {
	F1 int
}

type _testRegisterOutWithErrorAndContextOut struct {
	F1 int
}

func init() {
	app.ServiceAppMode = app.Ast

	var err error

	_testRegisterNullInCoder, err = coding.NewAvro(_testRegisterNullInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterNullOutCoder, err = coding.NewAvro(_testRegisterNullOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterOnlyInputInCoder, err = coding.NewAvro(_testRegisterOnlyInputInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterOnlyInputOutCoder, err = coding.NewAvro(_testRegisterOnlyInputOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterOnlyOutputInCoder, err = coding.NewAvro(_testRegisterOnlyOutputInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterOnlyOutputOutCoder, err = coding.NewAvro(_testRegisterOnlyOutputOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterBothInAndOutInCoder, err = coding.NewAvro(_testRegisterBothInAndOutInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterBothInAndOutOutCoder, err = coding.NewAvro(_testRegisterBothInAndOutOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterOutWithErrorInCoder, err = coding.NewAvro(_testRegisterOutWithErrorInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterOutWithErrorOutCoder, err = coding.NewAvro(_testRegisterOutWithErrorOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterOutWithContextInCoder, err = coding.NewAvro(_testRegisterOutWithContextInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterOutWithContextOutCoder, err = coding.NewAvro(_testRegisterOutWithContextOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterOutWithErrorAndContextInCoder, err = coding.NewAvro(_testRegisterOutWithErrorAndContextInSchema)
	if err != nil {
		panic(err)
	}
	_testRegisterOutWithErrorAndContextOutCoder, err = coding.NewAvro(_testRegisterOutWithErrorAndContextOutSchema)
	if err != nil {
		panic(err)
	}

	_testRegisterFuncList = []cRegister.FunInfo{

		{
			Name:      "Null",
			InSchema:  _testRegisterNullInSchema,
			OutSchema: _testRegisterNullOutSchema},

		{
			Name:      "OnlyInput",
			InSchema:  _testRegisterOnlyInputInSchema,
			OutSchema: _testRegisterOnlyInputOutSchema},

		{
			Name:      "OnlyOutput",
			InSchema:  _testRegisterOnlyOutputInSchema,
			OutSchema: _testRegisterOnlyOutputOutSchema},

		{
			Name:      "BothInAndOut",
			InSchema:  _testRegisterBothInAndOutInSchema,
			OutSchema: _testRegisterBothInAndOutOutSchema},

		{
			Name:      "OutWithError",
			InSchema:  _testRegisterOutWithErrorInSchema,
			OutSchema: _testRegisterOutWithErrorOutSchema},

		{
			Name:      "OutWithContext",
			InSchema:  _testRegisterOutWithContextInSchema,
			OutSchema: _testRegisterOutWithContextOutSchema},

		{
			Name:      "OutWithErrorAndContext",
			InSchema:  _testRegisterOutWithErrorAndContextInSchema,
			OutSchema: _testRegisterOutWithErrorAndContextOutSchema},
	}
}

func (d *testRegister) Do(ctx context.Context, fun string, param []byte) (result []byte, err error) {
	switch fun {

	case "Null":
		var in _testRegisterNullIn
		err = _testRegisterNullInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		d.Null()
		return []byte{1}, nil

	case "OnlyInput":
		var in _testRegisterOnlyInputIn
		err = _testRegisterOnlyInputInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		d.OnlyInput(
			in.F1,
		)
		return []byte{1}, nil

	case "OnlyOutput":
		var in _testRegisterOnlyOutputIn
		err = _testRegisterOnlyOutputInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		res1 := d.OnlyOutput()
		if err != nil {
			return nil, err
		}
		var out _testRegisterOnlyOutputOut
		out.F1 = res1

		res, err := _testRegisterOnlyOutputOutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil

	case "BothInAndOut":
		var in _testRegisterBothInAndOutIn
		err = _testRegisterBothInAndOutInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		res1 := d.BothInAndOut(

			in.F1,
		)
		if err != nil {
			return nil, err
		}
		var out _testRegisterBothInAndOutOut
		out.F1 = res1

		res, err := _testRegisterBothInAndOutOutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil

	case "OutWithError":
		var in _testRegisterOutWithErrorIn
		err = _testRegisterOutWithErrorInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		res1, err := d.OutWithError(

			in.F1,
		)
		if err != nil {
			return nil, err
		}
		var out _testRegisterOutWithErrorOut
		out.F1 = res1

		res, err := _testRegisterOutWithErrorOutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil

	case "OutWithContext":
		var in _testRegisterOutWithContextIn
		err = _testRegisterOutWithContextInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		res1, err := d.OutWithContext(
			ctx,
			in.F1,
		)
		if err != nil {
			return nil, err
		}
		var out _testRegisterOutWithContextOut
		out.F1 = res1

		res, err := _testRegisterOutWithContextOutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil

	case "OutWithErrorAndContext":
		var in _testRegisterOutWithErrorAndContextIn
		err = _testRegisterOutWithErrorAndContextInCoder.DecodeIn(param, &in)
		if err != nil {
			panic(err)
		}

		res1, err := d.OutWithErrorAndContext(
			ctx,
			in.F1,
		)
		if err != nil {
			return nil, err
		}
		var out _testRegisterOutWithErrorAndContextOut
		out.F1 = res1

		res, err := _testRegisterOutWithErrorAndContextOutCoder.Encode(out)
		if err != nil {
			panic(err)
		}
		return res, nil

	default:
		err = errors.New("rpc call error: fun not exist")
	}
	return
}

func (d *testRegister) FuncList() []cRegister.FunInfo {
	return _testRegisterFuncList
}
